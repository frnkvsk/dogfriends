{"ast":null,"code":"'use strict';\n\nconst is = require('./is');\n/**\n * Boolean operations for bandbool.\n * @private\n */\n\n\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction removeAlpha() {\n  this.options.removeAlpha = true;\n  return this;\n}\n/**\n * Ensure alpha channel, if missing. The added alpha channel will be fully opaque. This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png', function(err, info) {\n *     // rgba.png is a 4 channel image with a fully opaque alpha channel\n *   });\n *\n * @returns {Sharp}\n */\n\n\nfunction ensureAlpha() {\n  this.options.ensureAlpha = true;\n  return this;\n}\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * sharp(input)\n *   .extractChannel('green')\n *   .toColourspace('b-w')\n *   .toFile('green.jpg', function(err, info) {\n *     // info.channels === 1\n *     // green.jpg is a greyscale image containing the green channel of the input\n *    });\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\n\n\nfunction extractChannel(channel) {\n  const channelMap = {\n    red: 0,\n    green: 1,\n    blue: 2,\n    alpha: 3\n  };\n\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n\n  return this;\n}\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction joinChannel(images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n\n  return this;\n}\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\n\nfunction bandbool(boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n\n  return this;\n}\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\n\n\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  }); // Class attributes\n\n  Sharp.bool = bool;\n};","map":{"version":3,"sources":["/home/fv/js/capstone2/dogfriends/frontend/node_modules/sharp/lib/channel.js"],"names":["is","require","bool","and","or","eor","removeAlpha","options","ensureAlpha","extractChannel","channel","channelMap","red","green","blue","alpha","Object","keys","includes","integer","inRange","invalidParameterError","joinChannel","images","Array","isArray","forEach","image","joinChannelIn","push","_createInputDescriptor","bandbool","boolOp","string","inArray","bandBoolOp","module","exports","Sharp","assign","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\nconst is = require('./is');\n\n/**\n * Boolean operations for bandbool.\n * @private\n */\nconst bool = {\n  and: 'and',\n  or: 'or',\n  eor: 'eor'\n};\n\n/**\n * Remove alpha channel, if any. This is a no-op if the image does not have an alpha channel.\n *\n * @example\n * sharp('rgba.png')\n *   .removeAlpha()\n *   .toFile('rgb.png', function(err, info) {\n *     // rgb.png is a 3 channel image without an alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction removeAlpha () {\n  this.options.removeAlpha = true;\n  return this;\n}\n\n/**\n * Ensure alpha channel, if missing. The added alpha channel will be fully opaque. This is a no-op if the image already has an alpha channel.\n *\n * @since 0.21.2\n *\n * @example\n * sharp('rgb.jpg')\n *   .ensureAlpha()\n *   .toFile('rgba.png', function(err, info) {\n *     // rgba.png is a 4 channel image with a fully opaque alpha channel\n *   });\n *\n * @returns {Sharp}\n */\nfunction ensureAlpha () {\n  this.options.ensureAlpha = true;\n  return this;\n}\n\n/**\n * Extract a single channel from a multi-channel image.\n *\n * @example\n * sharp(input)\n *   .extractChannel('green')\n *   .toColourspace('b-w')\n *   .toFile('green.jpg', function(err, info) {\n *     // info.channels === 1\n *     // green.jpg is a greyscale image containing the green channel of the input\n *    });\n *\n * @param {number|string} channel - zero-indexed channel/band number to extract, or `red`, `green`, `blue` or `alpha`.\n * @returns {Sharp}\n * @throws {Error} Invalid channel\n */\nfunction extractChannel (channel) {\n  const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };\n  if (Object.keys(channelMap).includes(channel)) {\n    channel = channelMap[channel];\n  }\n  if (is.integer(channel) && is.inRange(channel, 0, 4)) {\n    this.options.extractChannel = channel;\n  } else {\n    throw is.invalidParameterError('channel', 'integer or one of: red, green, blue, alpha', channel);\n  }\n  return this;\n}\n\n/**\n * Join one or more channels to the image.\n * The meaning of the added channels depends on the output colourspace, set with `toColourspace()`.\n * By default the output image will be web-friendly sRGB, with additional channels interpreted as alpha channels.\n * Channel ordering follows vips convention:\n * - sRGB: 0: Red, 1: Green, 2: Blue, 3: Alpha.\n * - CMYK: 0: Magenta, 1: Cyan, 2: Yellow, 3: Black, 4: Alpha.\n *\n * Buffers may be any of the image formats supported by sharp.\n * For raw pixel input, the `options` object should contain a `raw` attribute, which follows the format of the attribute of the same name in the `sharp()` constructor.\n *\n * @param {Array<string|Buffer>|string|Buffer} images - one or more images (file paths, Buffers).\n * @param {Object} options - image options, see `sharp()` constructor.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction joinChannel (images, options) {\n  if (Array.isArray(images)) {\n    images.forEach(function (image) {\n      this.options.joinChannelIn.push(this._createInputDescriptor(image, options));\n    }, this);\n  } else {\n    this.options.joinChannelIn.push(this._createInputDescriptor(images, options));\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation on all input image channels (bands) to produce a single channel output image.\n *\n * @example\n * sharp('3-channel-rgb-input.png')\n *   .bandbool(sharp.bool.and)\n *   .toFile('1-channel-output.png', function (err, info) {\n *     // The output will be a single channel image where each pixel `P = R & G & B`.\n *     // If `I(1,1) = [247, 170, 14] = [0b11110111, 0b10101010, 0b00001111]`\n *     // then `O(1,1) = 0b11110111 & 0b10101010 & 0b00001111 = 0b00000010 = 2`.\n *   });\n *\n * @param {string} boolOp - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction bandbool (boolOp) {\n  if (is.string(boolOp) && is.inArray(boolOp, ['and', 'or', 'eor'])) {\n    this.options.bandBoolOp = boolOp;\n  } else {\n    throw is.invalidParameterError('boolOp', 'one of: and, or, eor', boolOp);\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with channel-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public instance functions\n    removeAlpha,\n    ensureAlpha,\n    extractChannel,\n    joinChannel,\n    bandbool\n  });\n  // Class attributes\n  Sharp.bool = bool;\n};\n"]},"metadata":{},"sourceType":"script"}