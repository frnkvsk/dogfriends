{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\n/* istanbul ignore next */\n\n\ntry {\n  require('../build/Release/sharp.node');\n} catch (err) {\n  // Bail early if bindings aren't available\n  const help = ['', 'Something went wrong installing the \"sharp\" module', '', err.message, ''];\n\n  if (/NODE_MODULE_VERSION/.test(err.message)) {\n    help.push('- Ensure the version of Node.js used at install time matches that used at runtime');\n  } else if (/invalid ELF header/.test(err.message)) {\n    help.push(`- Ensure \"${process.platform}\" is used at install time as well as runtime`);\n  } else if (/dylib/.test(err.message) && /Incompatible library version/.test(err.message)) {\n    help.push('- Run \"brew update && brew upgrade vips\"');\n  } else if (/Cannot find module/.test(err.message)) {\n    help.push('- Run \"npm rebuild --verbose sharp\" and look for errors');\n  } else {\n    help.push('- Remove the \"node_modules/sharp\" directory then run', '  \"npm install --ignore-scripts=false --verbose\" and look for errors');\n  }\n\n  help.push('- Consult the installation documentation at https://sharp.pixelplumbing.com/install', '- Search for this error at https://github.com/lovell/sharp/issues', '');\n  const error = help.join('\\n');\n  throw new Error(error);\n} // Use NODE_DEBUG=sharp to enable libvips warnings\n\n\nconst debuglog = util.debuglog('sharp');\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }.toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {boolean} [options.failOnError=true] - by default halt processing and raise an error when loading invalid images.\n *  Set this flag to `false` if you'd rather apply a \"best effort\" to decode images, even if the data is corrupt or invalid.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\n\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenFlat: 1,\n    sharpenJagged: 2,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: false,\n    colourspace: 'srgb',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataIcc: '',\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 9,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngColours: 256,\n    pngDither: 1,\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpReductionEffort: 4,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifSpeed: 5,\n    heifChromaSubsampling: '4:2:0',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, {\n    allowStream: true\n  });\n  return this;\n};\n\nutil.inherits(Sharp, stream.Duplex);\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({\n *   failOnError: false\n * });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\n\nfunction clone() {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options); // Pass 'finish' event to clone for Stream-based input\n\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n\n  return clone;\n}\n\nObject.assign(Sharp.prototype, {\n  clone\n});\n/**\n * Export constructor.\n * @private\n */\n\nmodule.exports = Sharp;","map":{"version":3,"sources":["/home/fv/js/capstone2/dogfriends/frontend/node_modules/sharp/lib/constructor.js"],"names":["util","require","stream","is","hasVendoredLibvips","err","help","message","test","push","process","platform","error","join","Error","debuglog","Sharp","input","options","arguments","length","defined","Duplex","call","topOffsetPre","leftOffsetPre","widthPre","heightPre","topOffsetPost","leftOffsetPost","widthPost","heightPost","width","height","canvas","position","resizeBackground","useExifOrientation","angle","rotationAngle","rotationBackground","rotateBeforePreExtract","flip","flop","extendTop","extendBottom","extendLeft","extendRight","extendBackground","withoutEnlargement","affineMatrix","affineBackground","affineIdx","affineIdy","affineOdx","affineOdy","affineInterpolator","constructor","interpolators","bilinear","kernel","fastShrinkOnLoad","tintA","tintB","flatten","flattenBackground","negate","medianSize","blurSigma","sharpenSigma","sharpenFlat","sharpenJagged","threshold","thresholdGrayscale","trimThreshold","gamma","gammaOut","greyscale","normalise","brightness","saturation","hue","booleanBufferIn","booleanFileIn","joinChannelIn","extractChannel","removeAlpha","ensureAlpha","colourspace","composite","fileOut","formatOut","streamOut","withMetadata","withMetadataOrientation","withMetadataIcc","resolveWithObject","jpegQuality","jpegProgressive","jpegChromaSubsampling","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegOptimiseCoding","jpegQuantisationTable","pngProgressive","pngCompressionLevel","pngAdaptiveFiltering","pngPalette","pngQuality","pngColours","pngDither","webpQuality","webpAlphaQuality","webpLossless","webpNearLossless","webpSmartSubsample","webpReductionEffort","tiffQuality","tiffCompression","tiffPredictor","tiffPyramid","tiffBitdepth","tiffTile","tiffTileHeight","tiffTileWidth","tiffXres","tiffYres","heifQuality","heifLossless","heifCompression","heifSpeed","heifChromaSubsampling","tileSize","tileOverlap","tileContainer","tileLayout","tileFormat","tileDepth","tileAngle","tileSkipBlanks","tileBackground","tileCentre","linearA","linearB","warning","emit","queueListener","queueLength","queue","_createInputDescriptor","allowStream","inherits","clone","Object","assign","_isStreamInput","on","_flattenBufferIn","bufferIn","prototype","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AAEAA,OAAO,CAAC,WAAD,CAAP,CAAqBG,kBAArB;AAEA;;;AACA,IAAI;AACFH,EAAAA,OAAO,CAAC,6BAAD,CAAP;AACD,CAFD,CAEE,OAAOI,GAAP,EAAY;AACZ;AACA,QAAMC,IAAI,GAAG,CAAC,EAAD,EAAK,oDAAL,EAA2D,EAA3D,EAA+DD,GAAG,CAACE,OAAnE,EAA4E,EAA5E,CAAb;;AACA,MAAI,sBAAsBC,IAAtB,CAA2BH,GAAG,CAACE,OAA/B,CAAJ,EAA6C;AAC3CD,IAAAA,IAAI,CAACG,IAAL,CAAU,mFAAV;AACD,GAFD,MAEO,IAAI,qBAAqBD,IAArB,CAA0BH,GAAG,CAACE,OAA9B,CAAJ,EAA4C;AACjDD,IAAAA,IAAI,CAACG,IAAL,CAAW,aAAYC,OAAO,CAACC,QAAS,8CAAxC;AACD,GAFM,MAEA,IAAI,QAAQH,IAAR,CAAaH,GAAG,CAACE,OAAjB,KAA6B,+BAA+BC,IAA/B,CAAoCH,GAAG,CAACE,OAAxC,CAAjC,EAAmF;AACxFD,IAAAA,IAAI,CAACG,IAAL,CAAU,0CAAV;AACD,GAFM,MAEA,IAAI,qBAAqBD,IAArB,CAA0BH,GAAG,CAACE,OAA9B,CAAJ,EAA4C;AACjDD,IAAAA,IAAI,CAACG,IAAL,CAAU,yDAAV;AACD,GAFM,MAEA;AACLH,IAAAA,IAAI,CAACG,IAAL,CACE,sDADF,EAEE,sEAFF;AAID;;AACDH,EAAAA,IAAI,CAACG,IAAL,CACE,qFADF,EAEE,mEAFF,EAEuE,EAFvE;AAIA,QAAMG,KAAK,GAAGN,IAAI,CAACO,IAAL,CAAU,IAAV,CAAd;AACA,QAAM,IAAIC,KAAJ,CAAUF,KAAV,CAAN;AACD,C,CAED;;;AACA,MAAMG,QAAQ,GAAGf,IAAI,CAACe,QAAL,CAAc,OAAd,CAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,KAAK,GAAG,UAAUC,KAAV,EAAiBC,OAAjB,EAA0B;AACtC,MAAIC,SAAS,CAACC,MAAV,KAAqB,CAArB,IAA0B,CAACjB,EAAE,CAACkB,OAAH,CAAWJ,KAAX,CAA/B,EAAkD;AAChD,UAAM,IAAIH,KAAJ,CAAU,eAAV,CAAN;AACD;;AACD,MAAI,EAAE,gBAAgBE,KAAlB,CAAJ,EAA8B;AAC5B,WAAO,IAAIA,KAAJ,CAAUC,KAAV,EAAiBC,OAAjB,CAAP;AACD;;AACDhB,EAAAA,MAAM,CAACoB,MAAP,CAAcC,IAAd,CAAmB,IAAnB;AACA,OAAKL,OAAL,GAAe;AACb;AACAM,IAAAA,YAAY,EAAE,CAAC,CAFF;AAGbC,IAAAA,aAAa,EAAE,CAAC,CAHH;AAIbC,IAAAA,QAAQ,EAAE,CAAC,CAJE;AAKbC,IAAAA,SAAS,EAAE,CAAC,CALC;AAMbC,IAAAA,aAAa,EAAE,CAAC,CANH;AAObC,IAAAA,cAAc,EAAE,CAAC,CAPJ;AAQbC,IAAAA,SAAS,EAAE,CAAC,CARC;AASbC,IAAAA,UAAU,EAAE,CAAC,CATA;AAUbC,IAAAA,KAAK,EAAE,CAAC,CAVK;AAWbC,IAAAA,MAAM,EAAE,CAAC,CAXI;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","sourcesContent":["'use strict';\n\nconst util = require('util');\nconst stream = require('stream');\nconst is = require('./is');\n\nrequire('./libvips').hasVendoredLibvips();\n\n/* istanbul ignore next */\ntry {\n  require('../build/Release/sharp.node');\n} catch (err) {\n  // Bail early if bindings aren't available\n  const help = ['', 'Something went wrong installing the \"sharp\" module', '', err.message, ''];\n  if (/NODE_MODULE_VERSION/.test(err.message)) {\n    help.push('- Ensure the version of Node.js used at install time matches that used at runtime');\n  } else if (/invalid ELF header/.test(err.message)) {\n    help.push(`- Ensure \"${process.platform}\" is used at install time as well as runtime`);\n  } else if (/dylib/.test(err.message) && /Incompatible library version/.test(err.message)) {\n    help.push('- Run \"brew update && brew upgrade vips\"');\n  } else if (/Cannot find module/.test(err.message)) {\n    help.push('- Run \"npm rebuild --verbose sharp\" and look for errors');\n  } else {\n    help.push(\n      '- Remove the \"node_modules/sharp\" directory then run',\n      '  \"npm install --ignore-scripts=false --verbose\" and look for errors'\n    );\n  }\n  help.push(\n    '- Consult the installation documentation at https://sharp.pixelplumbing.com/install',\n    '- Search for this error at https://github.com/lovell/sharp/issues', ''\n  );\n  const error = help.join('\\n');\n  throw new Error(error);\n}\n\n// Use NODE_DEBUG=sharp to enable libvips warnings\nconst debuglog = util.debuglog('sharp');\n\n/**\n * Constructor factory to create an instance of `sharp`, to which further methods are chained.\n *\n * JPEG, PNG, WebP, AVIF or TIFF format image data can be streamed out from this object.\n * When using Stream based output, derived attributes are available from the `info` event.\n *\n * Non-critical problems encountered during processing are emitted as `warning` events.\n *\n * Implements the [stream.Duplex](http://nodejs.org/api/stream.html#stream_class_stream_duplex) class.\n *\n * @constructs Sharp\n *\n * @emits Sharp#info\n * @emits Sharp#warning\n *\n * @example\n * sharp('input.jpg')\n *   .resize(300, 200)\n *   .toFile('output.jpg', function(err) {\n *     // output.jpg is a 300 pixels wide and 200 pixels high image\n *     // containing a scaled and cropped version of input.jpg\n *   });\n *\n * @example\n * // Read image data from readableStream,\n * // resize to 300 pixels wide,\n * // emit an 'info' event with calculated dimensions\n * // and finally write image data to writableStream\n * var transformer = sharp()\n *   .resize(300)\n *   .on('info', function(info) {\n *     console.log('Image height is ' + info.height);\n *   });\n * readableStream.pipe(transformer).pipe(writableStream);\n *\n * @example\n * // Create a blank 300x200 PNG image of semi-transluent red pixels\n * sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 4,\n *     background: { r: 255, g: 0, b: 0, alpha: 0.5 }\n *   }\n * })\n * .png()\n * .toBuffer()\n * .then( ... );\n *\n * @example\n * // Convert an animated GIF to an animated WebP\n * await sharp('in.gif', { animated: true }).toFile('out.webp');\n *\n * @example\n * // Read a raw array of pixels and save it to a png\n * const input = Uint8Array.from([255, 255, 255, 0, 0, 0]); // or Uint8ClampedArray\n * const image = sharp(input, {\n *   // because the input does not contain its dimensions or how many channels it has\n *   // we need to specify it in the constructor options\n *   raw: {\n *     width: 2,\n *     height: 1,\n *     channels: 3\n *   }\n * });\n * await image.toFile('my-two-pixels.png');\n *\n * @example\n * // Generate RGB Gaussian noise\n * await sharp({\n *   create: {\n *     width: 300,\n *     height: 200,\n *     channels: 3,\n *     noise: {\n *       type: 'gaussian',\n *       mean: 128,\n *       sigma: 30\n *     }\n *  }\n * }.toFile('noise.png');\n *\n * @param {(Buffer|Uint8Array|Uint8ClampedArray|string)} [input] - if present, can be\n *  a Buffer / Uint8Array / Uint8ClampedArray containing JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data, or\n *  a String containing the filesystem path to an JPEG, PNG, WebP, AVIF, GIF, SVG or TIFF image file.\n *  JPEG, PNG, WebP, AVIF, GIF, SVG, TIFF or raw pixel image data can be streamed into the object when not present.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {boolean} [options.failOnError=true] - by default halt processing and raise an error when loading invalid images.\n *  Set this flag to `false` if you'd rather apply a \"best effort\" to decode images, even if the data is corrupt or invalid.\n * @param {number|boolean} [options.limitInputPixels=268402689] - Do not process input images where the number of pixels\n *  (width x height) exceeds this limit. Assumes image dimensions contained in the input metadata can be trusted.\n *  An integral Number of pixels, zero or false to remove limit, true to use default limit of 268402689 (0x3FFF x 0x3FFF).\n * @param {boolean} [options.sequentialRead=false] - Set this to `true` to use sequential rather than random access where possible.\n *  This can reduce memory usage and might improve performance on some systems.\n * @param {number} [options.density=72] - number representing the DPI for vector images in the range 1 to 100000.\n * @param {number} [options.pages=1] - number of pages to extract for multi-page input (GIF, WebP, AVIF, TIFF, PDF), use -1 for all pages.\n * @param {number} [options.page=0] - page number to start extracting from for multi-page input (GIF, WebP, AVIF, TIFF, PDF), zero based.\n * @param {number} [options.level=0] - level to extract from a multi-level input (OpenSlide), zero based.\n * @param {boolean} [options.animated=false] - Set to `true` to read all frames/pages of an animated image (equivalent of setting `pages` to `-1`).\n * @param {Object} [options.raw] - describes raw pixel input image data. See `raw()` for pixel ordering.\n * @param {number} [options.raw.width] - integral number of pixels wide.\n * @param {number} [options.raw.height] - integral number of pixels high.\n * @param {number} [options.raw.channels] - integral number of channels, between 1 and 4.\n * @param {Object} [options.create] - describes a new image to be created.\n * @param {number} [options.create.width] - integral number of pixels wide.\n * @param {number} [options.create.height] - integral number of pixels high.\n * @param {number} [options.create.channels] - integral number of channels, either 3 (RGB) or 4 (RGBA).\n * @param {string|Object} [options.create.background] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Object} [options.create.noise] - describes a noise to be created.\n * @param {string} [options.create.noise.type] - type of generated noise, currently only `gaussian` is supported.\n * @param {number} [options.create.noise.mean] - mean of pixels in generated noise.\n * @param {number} [options.create.noise.sigma] - standard deviation of pixels in generated noise.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nconst Sharp = function (input, options) {\n  if (arguments.length === 1 && !is.defined(input)) {\n    throw new Error('Invalid input');\n  }\n  if (!(this instanceof Sharp)) {\n    return new Sharp(input, options);\n  }\n  stream.Duplex.call(this);\n  this.options = {\n    // resize options\n    topOffsetPre: -1,\n    leftOffsetPre: -1,\n    widthPre: -1,\n    heightPre: -1,\n    topOffsetPost: -1,\n    leftOffsetPost: -1,\n    widthPost: -1,\n    heightPost: -1,\n    width: -1,\n    height: -1,\n    canvas: 'crop',\n    position: 0,\n    resizeBackground: [0, 0, 0, 255],\n    useExifOrientation: false,\n    angle: 0,\n    rotationAngle: 0,\n    rotationBackground: [0, 0, 0, 255],\n    rotateBeforePreExtract: false,\n    flip: false,\n    flop: false,\n    extendTop: 0,\n    extendBottom: 0,\n    extendLeft: 0,\n    extendRight: 0,\n    extendBackground: [0, 0, 0, 255],\n    withoutEnlargement: false,\n    affineMatrix: [],\n    affineBackground: [0, 0, 0, 255],\n    affineIdx: 0,\n    affineIdy: 0,\n    affineOdx: 0,\n    affineOdy: 0,\n    affineInterpolator: this.constructor.interpolators.bilinear,\n    kernel: 'lanczos3',\n    fastShrinkOnLoad: true,\n    // operations\n    tintA: 128,\n    tintB: 128,\n    flatten: false,\n    flattenBackground: [0, 0, 0],\n    negate: false,\n    medianSize: 0,\n    blurSigma: 0,\n    sharpenSigma: 0,\n    sharpenFlat: 1,\n    sharpenJagged: 2,\n    threshold: 0,\n    thresholdGrayscale: true,\n    trimThreshold: 0,\n    gamma: 0,\n    gammaOut: 0,\n    greyscale: false,\n    normalise: false,\n    brightness: 1,\n    saturation: 1,\n    hue: 0,\n    booleanBufferIn: null,\n    booleanFileIn: '',\n    joinChannelIn: [],\n    extractChannel: -1,\n    removeAlpha: false,\n    ensureAlpha: false,\n    colourspace: 'srgb',\n    composite: [],\n    // output\n    fileOut: '',\n    formatOut: 'input',\n    streamOut: false,\n    withMetadata: false,\n    withMetadataOrientation: -1,\n    withMetadataIcc: '',\n    resolveWithObject: false,\n    // output format\n    jpegQuality: 80,\n    jpegProgressive: false,\n    jpegChromaSubsampling: '4:2:0',\n    jpegTrellisQuantisation: false,\n    jpegOvershootDeringing: false,\n    jpegOptimiseScans: false,\n    jpegOptimiseCoding: true,\n    jpegQuantisationTable: 0,\n    pngProgressive: false,\n    pngCompressionLevel: 9,\n    pngAdaptiveFiltering: false,\n    pngPalette: false,\n    pngQuality: 100,\n    pngColours: 256,\n    pngDither: 1,\n    webpQuality: 80,\n    webpAlphaQuality: 100,\n    webpLossless: false,\n    webpNearLossless: false,\n    webpSmartSubsample: false,\n    webpReductionEffort: 4,\n    tiffQuality: 80,\n    tiffCompression: 'jpeg',\n    tiffPredictor: 'horizontal',\n    tiffPyramid: false,\n    tiffBitdepth: 8,\n    tiffTile: false,\n    tiffTileHeight: 256,\n    tiffTileWidth: 256,\n    tiffXres: 1.0,\n    tiffYres: 1.0,\n    heifQuality: 50,\n    heifLossless: false,\n    heifCompression: 'av1',\n    heifSpeed: 5,\n    heifChromaSubsampling: '4:2:0',\n    tileSize: 256,\n    tileOverlap: 0,\n    tileContainer: 'fs',\n    tileLayout: 'dz',\n    tileFormat: 'last',\n    tileDepth: 'last',\n    tileAngle: 0,\n    tileSkipBlanks: -1,\n    tileBackground: [255, 255, 255, 255],\n    tileCentre: false,\n    linearA: 1,\n    linearB: 0,\n    // Function to notify of libvips warnings\n    debuglog: warning => {\n      this.emit('warning', warning);\n      debuglog(warning);\n    },\n    // Function to notify of queue length changes\n    queueListener: function (queueLength) {\n      Sharp.queue.emit('change', queueLength);\n    }\n  };\n  this.options.input = this._createInputDescriptor(input, options, { allowStream: true });\n  return this;\n};\nutil.inherits(Sharp, stream.Duplex);\n\n/**\n * Take a \"snapshot\" of the Sharp instance, returning a new instance.\n * Cloned instances inherit the input of their parent instance.\n * This allows multiple output Streams and therefore multiple processing pipelines to share a single input Stream.\n *\n * @example\n * const pipeline = sharp().rotate();\n * pipeline.clone().resize(800, 600).pipe(firstWritableStream);\n * pipeline.clone().extract({ left: 20, top: 20, width: 100, height: 100 }).pipe(secondWritableStream);\n * readableStream.pipe(pipeline);\n * // firstWritableStream receives auto-rotated, resized readableStream\n * // secondWritableStream receives auto-rotated, extracted region of readableStream\n *\n * @example\n * // Create a pipeline that will download an image, resize it and format it to different files\n * // Using Promises to know when the pipeline is complete\n * const fs = require(\"fs\");\n * const got = require(\"got\");\n * const sharpStream = sharp({\n *   failOnError: false\n * });\n *\n * const promises = [];\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .jpeg({ quality: 100 })\n *     .toFile(\"originalFile.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .jpeg({ quality: 80 })\n *     .toFile(\"optimized-500.jpg\")\n * );\n *\n * promises.push(\n *   sharpStream\n *     .clone()\n *     .resize({ width: 500 })\n *     .webp({ quality: 80 })\n *     .toFile(\"optimized-500.webp\")\n * );\n *\n * // https://github.com/sindresorhus/got#gotstreamurl-options\n * got.stream(\"https://www.example.com/some-file.jpg\").pipe(sharpStream);\n *\n * Promise.all(promises)\n *   .then(res => { console.log(\"Done!\", res); })\n *   .catch(err => {\n *     console.error(\"Error processing files, let's clean it up\", err);\n *     try {\n *       fs.unlinkSync(\"originalFile.jpg\");\n *       fs.unlinkSync(\"optimized-500.jpg\");\n *       fs.unlinkSync(\"optimized-500.webp\");\n *     } catch (e) {}\n *   });\n *\n * @returns {Sharp}\n */\nfunction clone () {\n  // Clone existing options\n  const clone = this.constructor.call();\n  clone.options = Object.assign({}, this.options);\n  // Pass 'finish' event to clone for Stream-based input\n  if (this._isStreamInput()) {\n    this.on('finish', () => {\n      // Clone inherits input data\n      this._flattenBufferIn();\n      clone.options.bufferIn = this.options.bufferIn;\n      clone.emit('finish');\n    });\n  }\n  return clone;\n}\nObject.assign(Sharp.prototype, { clone });\n\n/**\n * Export constructor.\n * @private\n */\nmodule.exports = Sharp;\n"]},"metadata":{},"sourceType":"script"}